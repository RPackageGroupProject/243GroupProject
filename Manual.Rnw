\documentclass{article}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

\begin{document}
\title{Final Project}
\author{.....Chris Gagne}
\date{Dec 15 2017}

\maketitle

<<setup, include=FALSE>>=
library(knitr) # need this for opts_chunk command
opts_chunk$set(fig.width = 3, fig.height = 3)
library(sads)
@

\section*{Description of Algorithm and Approach to Modularization}

Our package has one main function select(). This does the entire genetic algorithm on a dataset containing rows as examples and columns as variables.

Our approach to modularization was break the genetic algorithm into its natural processes.
(1) initialize population of chromosomes initialize(),
(2) calculation of fitness fitness(),
(3) selection of parents for breeding selection(),
(4) breeding parents and choosing the next generation nextGeneration(). Within this function, we use crossover() to do the actual breeding and mutation().

We allow changes to the general algorithm in a number of ways:

We implemented 3 ways to select the parent generation. The first method was to use fitness-rank-based probabilities to select both parents in the pairs chosen to breed. The second method used fitness-rank-based probabilities to choose just one parent in each pair, and the second parent was chosen randomly. This might help preserved diversity in population, which is important for not converging to local minimum. The third method is tournament selection, which FILL IN HERE. These methods can be toggled between by the user by using the K parameter.

We also implemented a flexible generation gap (the percent of children replacing the parents in each generation) as well as allowed for a user specified number of generations and starting population size.

In terms of represenation, our chromosomes are boolean vectors which are used to index an X-matrix, with columns for each predictor variables. The population set of chromosomes is a matrix of the boolean chromosome vectors and is passed into various functions. nextGeneration() returns a modified version of the population set of chromosomes. We did this, rather than keep old generation chromosomes, to save memory. We do, however, store the fitness scores for each model for each generation that we use to plot the progress of the algorithm (see examples).


\section*{Examples}


asdfasdf

<<r-chunk1, eval=TRUE, cache=TRUE,fig.width=8,fig.height=4>>=


@

\end{document}
